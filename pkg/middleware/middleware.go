// Copyright 2023 Matcha Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package middleware defines the middleware format for Matcha.
//
// See [https://github.com/decentplatforms/matcha/blob/main/docs/routers.md#middleware].
package middleware

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"
)

// Middleware runs on any incoming request. Attachment behavior is defined by the structure it's attached to (route vs. router).
//
// Returns an *http.Request; the middleware can set router params or reject a request by returning nil.
type Middleware func(http.ResponseWriter, *http.Request) *http.Request

// The string used to indicate an absent origin in log entries.
//
// Origins take one of the following forms, so must not take any of these forms:
//
//	"null"
//	"<scheme>://<hostname>"
//	"<scheme>://<hostname>:<port>"
const OriginAbsent = "-"

// Returns a middleware that logs the details of an incoming request.
//
// Log entries take the form "<timestamp> <origin> <HTTP method> <url>". If no
// origin is provided with the request, <origin> will be OriginAbsent. <timestamp>
// is an integer, the number of nanoseconds since the Unix Epoch.
func LogRequests(w io.Writer) Middleware {
	return func(_ http.ResponseWriter, r *http.Request) *http.Request {
		logRequest(w, r)
		return r
	}
}

// Returns a middleware that logs the details of an incoming request only if
// test(request) == true. Log entries use the same format as LogRequests.
func LogRequestsIf(test func(*http.Request) bool, w io.Writer) Middleware {
	return func(_ http.ResponseWriter, r *http.Request) *http.Request {
		if test(r) {
			logRequest(w, r)
		}
		return r
	}
}

func logRequest(w io.Writer, r *http.Request) {
	origin := r.Header.Get("Origin")
	if origin == "" {
		origin = OriginAbsent
	}
	fmt.Fprintf(
		w,
		"%d %s %s %s\n",
		time.Now().UnixNano(),
		origin,
		r.Method,
		r.URL,
	)
}

// Parses a log entry generated by LogRequests or LogRequestsIf. See LogRequests
// for the log entry format.
func ParseLog(s string) (*LogEntry, error) {
	var log LogEntry
	var rawTimestamp int64
	var rawOrigin string
	var rawURL string
	_, err := fmt.Sscanf(
		s,
		"%d %s %s %s",
		&rawTimestamp,
		&rawOrigin,
		&log.Method,
		&rawURL,
	)
	if err != nil {
		return nil, err
	}

	log.Timestamp = time.Unix(0, rawTimestamp)

	if rawOrigin == OriginAbsent {
		log.Origin = ""
	} else {
		log.Origin = rawOrigin
	}

	log.URL, err = url.Parse(rawURL)
	if err != nil {
		return nil, err
	}

	return &log, nil
}

type LogEntry struct {
	Timestamp time.Time
	// Will be an empty string "" if no origin header was given on the request.
	Origin string
	Method string
	URL    *url.URL
}

// Executes the given middleware functions on the given request.
// It returns the modified request or nil if any middleware function returns nil.
func ExecuteMiddleware(mw []Middleware, w http.ResponseWriter, req *http.Request) *http.Request {
	for _, m := range mw {
		req = m(w, req)
		if req == nil {
			break
		}
	}
	return req
}
